#!/bin/bash
function RTFM() {
printf " Usage:	        $0 -n [NGINX] -a [APACHE] -h [host to add] -d [directory] -s [SSL] -l [port]"
printf " \n"
printf " -n             Use NGINX as webserver\n"
printf " -a             Use APACHE as webserver\n"
printf " -h             Hostname/domainname to add\n"
printf " -d             Directory of web files\n"
printf " -s             Obtain SSL cert using Let\'s Encrypt\n"
printf " -l             Use localhost proxy\n"
}

#########################################
#        Declare our functions          #
#########################################

function writenginxconf() {
cat <<EOF
# Default server configuration
#
server {
        listen 80;
        listen [::]:80;

        # SSL configuration
        #
        # listen 443 ssl default_server;
        # listen [::]:443 ssl default_server;
        #
        # Note: You should disable gzip for SSL traffic.
        # See: https://bugs.debian.org/773332
        #
        # Read up on ssl_ciphers to ensure a secure configuration.
        # See: https://bugs.debian.org/765782
        #
        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        #
        # include snippets/snakeoil.conf;

        root $webdir;

        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html;

        server_name $domain;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files \$uri \$uri/ =404;
	        # proxy_pass http://localhost:8080;
        	# proxy_http_version 1.1;
	        # proxy_set_header Upgrade \$http_upgrade;
        	# proxy_set_header Connection 'upgrade';
	        # proxy_set_header Host \$host;
        	# proxy_cache_bypass \$http_upgrade;
        }

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php\$ {
        #       include snippets/fastcgi-php.conf;
        #
        #       # With php7.0-cgi alone:
        #       fastcgi_pass 127.0.0.1:9000;
        #       # With php7.0-fpm:
        #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #       deny all;
        #}
}
EOF
}

function writenginxlocal() {
cat <<EOF
# Default server configuration
#
server {
        listen 80;
        listen [::]:80;

        # SSL configuration
        #
        # listen 443 ssl default_server;
        # listen [::]:443 ssl default_server;
        #
        # Note: You should disable gzip for SSL traffic.
        # See: https://bugs.debian.org/773332
        #
        # Read up on ssl_ciphers to ensure a secure configuration.
        # See: https://bugs.debian.org/765782
        #
        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        #
        # include snippets/snakeoil.conf;

        root $webdir;

        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html;

        server_name $domain;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                # try_files \$uri \$uri/ =404;
	        proxy_pass http://localhost:$port;
        	proxy_http_version 1.1;
	        proxy_set_header Upgrade \$http_upgrade;
        	proxy_set_header Connection 'upgrade';
	        proxy_set_header Host \$host;
        	proxy_cache_bypass \$http_upgrade;
        }

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php\$ {
        #       include snippets/fastcgi-php.conf;
        #
        #       # With php7.0-cgi alone:
        #       fastcgi_pass 127.0.0.1:9000;
        #       # With php7.0-fpm:
        #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #       deny all;
        #}
}
EOF
}

function writeapacheconf() {
  cat <<EOF
  <VirtualHost *:80>
        # The ServerName directive sets the request scheme, hostname and port that
        # the server uses to identify itself. This is used when creating
        # redirection URLs. In the context of virtual hosts, the ServerName
        # specifies what hostname must appear in the request's Host: header to
        # match this virtual host. For the default virtual host (this file) this
        # value is not decisive as it is used as a last resort host regardless.
        # However, you must set it for any further virtual host explicitly.
        ServerName $domain

        ServerAdmin webmaster@localhost
        DocumentRoot $webdir

        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
        # error, crit, alert, emerg.
        # It is also possible to configure the loglevel for particular
        # modules, e.g.
        #LogLevel info ssl:warn

        ErrorLog \${APACHE_LOG_DIR}/error.log
        CustomLog \${APACHE_LOG_DIR}/access.log combined

        # For most configuration files from conf-available/, which are
        # enabled or disabled at a global level, it is possible to
        # include a line for only one particular virtual host. For example the                                                                                                                                                                       # following line enables the CGI configuration for this host only                                                                                                                                                                            # after it has been globally disabled with "a2disconf".                                                                                                                                                                                      #Include conf-available/serve-cgi-bin.conf
</VirtualHost>
EOF
}

function writeapachelocal() {
  cat <<EOF
  <VirtualHost *:80>
        # The ServerName directive sets the request scheme, hostname and port that
        # the server uses to identify itself. This is used when creating
        # redirection URLs. In the context of virtual hosts, the ServerName
        # specifies what hostname must appear in the request's Host: header to
        # match this virtual host. For the default virtual host (this file) this
        # value is not decisive as it is used as a last resort host regardless.
        # However, you must set it for any further virtual host explicitly.
        ServerName $domain

        ServerAdmin webmaster@localhost
        DocumentRoot $webdir

        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
        # error, crit, alert, emerg.
        # It is also possible to configure the loglevel for particular
        # modules, e.g.
        #LogLevel info ssl:warn

        ProxyPass "/"  "http://localhost:$port/"
        ProxyPassReverse "/"  "http://localhost:$port/"
        ErrorLog \${APACHE_LOG_DIR}/error.log
        CustomLog \${APACHE_LOG_DIR}/access.log combined

        # For most configuration files from conf-available/, which are
        # enabled or disabled at a global level, it is possible to
        # include a line for only one particular virtual host. For example the                                                                                                                                                                       # following line enables the CGI configuration for this host only                                                                                                                                                                            # after it has been globally disabled with "a2disconf".                                                                                                                                                                                      #Include conf-available/serve-cgi-bin.conf
</VirtualHost>
EOF
}

# Initialise the variables
webserver=
domain=
webdir=
usessl=
port=

# This program really should be run as root...
if [[ $(id -u) -gt 0 ]]; then
	echo Please run as root!
	exit 1
fi

while getopts "nah:d:sl:" args
 do
  case $args in
    n)
        if [[ -n $webserver ]]; then
          echo Please use either -n or -a !
          echo
          exit 1
        else
          webserver=nginx
        fi
    ;;
    a)
    	if [[ -n $webserver ]]; then
          echo Please use either -n or -a !
          echo
          exit 1
        else
          webserver=apache
     	fi
    ;;
    h)
          if [[ $OPTARG == "" ]]; then
            echo Please provide a domainname!
            echo
            exit 1
          else
            domain=$OPTARG
          fi
    ;;
    d)
        webdir=$OPTARG
        if [[ ! -d $webdir ]]; then
          printf "$webdir doesn't seem to exist, creating it for you.\n"
          mkdir -p $webdir
        fi
    ;;
    s)
        usessl=true
    ;;
    l)
      if [[ $OPTARG == "" ]]; then
        Please provide a port!
        exit 1
      elif [[ ! $OPTARG -eq $OPTARG ]]; then
        echo Please provide a number!
        exit 1
      else
        port=$OPTARG
      fi
    ;;
    *)
        RTFM
        exit 1
    ;;
    esac
done

# Check if args are given
if [[ "x" == "x$webdir" && $port -ne "" ]]; then
  echo Webdirectory not specified! Exiting!
  echo
  RTFM
  exit 1
fi
if [[ "d" == "x$domain" ]]; then
  echo Manditory option for domain not specified! Exiting!
  echo
  RTFM
  exit 1
fi
if [[ "w" == "w$webserver" ]]; then
  echo Webserver not specified! Please double-check and try again!
  echo
  RTFM
  exit 1
fi

# Let's begin
if [[ $webserver == "apache" ]]; then
	if [[ -e /usr/bin/pacman ]]; then
        if pacman -Q apache2; then
          # nginx has been installed, make directories for the virtualhosts, this will fail if dirs are already present but that's okay.
          mkdir /etc/apache2/sites-available 2>&1 1>/dev/null
          mkdir /etc/apache2/sites-enabled 2>&1 1>/dev/null
          # Check if the servername (domain) is already in the nginx.conf files
          if grep -r "ServerName $domain" /etc/apache2/sites-*/* ; then
              echo $domain already present in conf file! Quitting!
              echo
              exit 1
          else
            :
          fi
      	else pacman -Syy apache2
          mkdir /etc/apache2/sites-available 2>&1 1>/dev/null
          mkdir /etc/apache2/sites-enabled 2>&1 1>/dev/null
        fi
    fi
        if [[ -e /usr/bin/apt ]]; then
          if [[ -d /etc/apache2 ]] ; then
            :
          else
            echo Apache2 not installed, installing now.
            sleep 2
            echo Updating apt
            echo
            apt-get update -qq
            echo Installing apache2
            echo
            apt-get install apache2 -y -qq
            echo Done.
          fi
        fi
	echo Removing default configuration files...
	rm -f /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-enabled/000-default.conf 2>/dev/null
	echo Writing apache configuration file for $domain.
  if [[ $port -ne "" ]]; then
    writeapachelocal >/etc/apache2/sites-available/$domain.conf
    echo Enabling modules
    a2enmod proxy
    a2enmod proxy_http
    a2enmod proxy_balancer
    echo Creating symlinks.
	  ln -s /etc/apache2/sites-available/$domain.conf /etc/apache2/sites-enabled/$domain.conf
	  echo Restarting Apache.
    systemctl restart apache2
    echo Done
  else
	  writeapacheconf >/etc/apache2/sites-available/$domain.conf
	  echo Enabling support for .htaccess
    sed -i 's/AllowOverride None/AllowOverride All/g' /etc/apache2/apache2.conf
    echo Creating symlinks.
	  ln -s /etc/apache2/sites-available/$domain.conf /etc/apache2/sites-enabled/$domain.conf
    echo Restarting Apache.
    systemctl restart apache2
	  echo Done
	  echo
  fi
fi
if [[ $usessl == "true" ]]; then
	if [[ -e /usr/bin/apt ]]; then
    if [[ -e /usr/bin/snap ]]; then
      sudo snap install core
      sudo snap refresh core
      sudo snap install --classic certbot
      sudo ln -s /snap/bin/certbot /usr/bin/certbot
      certbot --$webserver
      elif	dpkg --get-selections | grep certbot >/dev/null; then
			# Certbot is installed, let's make use of it.
       		certbot --$webserver
      	else
 	        echo Installing certbot using apt
        	echo Updating apt repositories
        	apt update -qq
        	echo Installing software-properties-common
        	apt install software-properties-common -y -qq
        	echo Adding apt repositories
         	add-apt-repository universe
         	add-apt-repository ppa:certbot/certbot
          echo Installing certbot
          apt install certbot python3-certbot-$webserver -y -qq
          certbot --$webserver
        fi
    fi
    if [[ -e /usr/bin/pacman ]]; then
    	if pacman -Q certbot; then
        	certbot --$webserver
        else
        	pacman -Syy certbot certbot-$webserver
        	certbot --$webserver
        fi
   	fi
fi
if [[ $webserver == "nginx" ]]; then
	if [[ -e /usr/bin/pacman ]]; then
		if pacman -Q nginx; then
		    # nginx has been installed, make directories for the virtualhosts, this will fail if dirs are already present but that's okay.
		    mkdir /etc/nginx/sites-available 2>&1 1>/dev/null
		    mkdir /etc/nginx/sites-enabled 2>&1 1>/dev/null
    		# Check if the servername (domain) is already in the nginx.conf files
    		if grep "server_name $domain" /etc/nginx/sites-*/*.conf ; then
    			echo $domain already present in conf file! Quitting!
    			exit 1
    		fi
  		else
  			pacman -Syy nginx
   			mkdir /etc/nginx/sites-available 2>&1 1>/dev/null
    		mkdir /etc/nginx/sites-enabled 2>&1 1>/dev/null
    	fi
	fi
  	if [[ -e /usr/bin/apt ]]; then
   		if [[ -d /etc/nginx ]]; then
           		:
    		else
        	echo Nginx not installed, installing now.
        	sleep 2
        	echo Updating apt
        	echo
        	apt-get update -qq
        	echo Installing nginx
        	echo
        	apt install nginx -y -qq
        	echo Done.
    		fi
	fi
	if [[ $port -ne "" ]]; then
		#  writenginxconf >/etc/nginx/sites-available/$domain.conf
		writenginxlocal >/etc/nginx/sites-available/$domain.conf
		ln -s /etc/nginx/sites-available/$domain.conf /etc/nginx/sites-enabled/$domain.conf
    systemctl restart nginx
  	exit
	else
    writenginxconf >/etc/nginx/sites-available/$domain.conf
    ln -s /etc/nginx/sites-available/$domain.conf /etc/nginx/sites-enabled/$domain.conf
    systemctl restart nginx
  fi
fi
